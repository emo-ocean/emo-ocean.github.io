<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Emo-Ocean's Blog</title><link>https://emo-ocean.github.io</link><description>Exploring Concepts and Innovations</description><copyright>Emo-Ocean's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/116006682?v=4</url><title>avatar</title><link>https://emo-ocean.github.io</link></image><lastBuildDate>Fri, 16 Aug 2024 08:15:48 +0000</lastBuildDate><managingEditor>Emo-Ocean's Blog</managingEditor><ttl>60</ttl><webMaster>Emo-Ocean's Blog</webMaster><item><title>Data Compression</title><link>https://emo-ocean.github.io/post/Data%20Compression.html</link><description># æ•°æ®å‹ç¼©&#13;
&#13;
## Huffman coding:&#13;
 åœ¨å“ˆå¤«æ›¼ç¼–ç ä¸­ï¼Œé¦–å…ˆä¼šç»Ÿè®¡æ–‡ä»¶ä¸­å„å­—ç¬¦å‡ºç°çš„æ¬¡æ•°æ¥ä»£è¡¨æƒé‡ï¼Œè€Œæƒé‡å¤§çš„å­—ç¬¦å‡ºç°æ¬¡æ•°æ›´å¤šï¼Œç”¨ä»¥æ›´çŸ­çš„ç¼–ç åºåˆ—ï¼ˆä¹Ÿå°±æ˜¯æ›´é è¿‘æ ¹èŠ‚ç‚¹çš„å±‚æ¬¡ï¼‰å¯ä»¥è®©å‹ç¼©åçš„æ•°æ®è§„æ¨¡æ›´å°&#13;
&#13;
&#13;
```python&#13;
# æ„å»ºå“ˆå¤«æ›¼æ ‘&#13;
from collections import Counter&#13;
import heapq&#13;
&#13;
&#13;
class Node:&#13;
    def __init__(self, char, freq):&#13;
        self.char = char&#13;
        self.freq = freq&#13;
        self.left = None&#13;
        self.right = None&#13;
&#13;
    # å®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œä½¿å¾—Nodeç±»å¯ä»¥åœ¨ä¼˜å…ˆé˜Ÿåˆ—ä¸­æ’åº&#13;
    def __lt__(self, other):&#13;
        return self.freq &lt; other.freq&#13;
&#13;
&#13;
def build_huffman_tree(text_build):&#13;
    frequency = Counter(text_build)&#13;
    heap = [Node(char, freq) for char, freq in frequency.items()]&#13;
    heapq.heapify(heap)&#13;
&#13;
    while len(heap) &gt; 1:&#13;
        node1 = heapq.heappop(heap)&#13;
        node2 = heapq.heappop(heap)&#13;
        merged = Node(None, node1.freq + node2.freq)&#13;
        merged.left = node1&#13;
        merged.right = node2&#13;
        heapq.heappush(heap, merged)&#13;
&#13;
    return heap[0]&#13;
&#13;
&#13;
# åˆ›å»ºå“ˆå¤«æ›¼ç¼–ç è¡¨&#13;
def build_codes_table(root_build):&#13;
    codes = {}&#13;
&#13;
    def build_codes(node, current_code):&#13;
        if node is None:&#13;
            return&#13;
&#13;
        if node.char is not None:&#13;
            codes[node.char] = current_code&#13;
&#13;
        build_codes(node.left, current_code + '0')&#13;
        build_codes(node.right, current_code + '1')&#13;
&#13;
    build_codes(root_build, '')&#13;
    return codes&#13;
&#13;
&#13;
# å‹ç¼©æ•°æ®&#13;
def huffman_compress(text_compress):&#13;
    root_compress = build_huffman_tree(text_compress)&#13;
    codes_table_c = build_codes_table(root_compress)&#13;
    encoded_text = ''.join(codes_table_c[char] for char in text_compress)&#13;
    return encoded_text, codes_table_c, root_compress&#13;
&#13;
&#13;
# è§£å‹æ•°æ®&#13;
def huffman_decompress(encoded_text, root_decompress):&#13;
    decoded_text = []&#13;
    node = root_decompress&#13;
    for bit in encoded_text:&#13;
        if bit == '0':&#13;
            node = node.left&#13;
        else:&#13;
            node = node.right&#13;
&#13;
        if node.left is None and node.right is None:&#13;
            decoded_text.append(node.char)&#13;
            node = root_decompress&#13;
&#13;
    return ''.join(decoded_text)&#13;
&#13;
&#13;
# ä»æ–‡ä»¶ä¸­è¯»å–æ–‡æœ¬æ•°æ®ï¼Œä½¿ç”¨ utf-8 ç¼–ç &#13;
def read_text_from_file(file_path):&#13;
    with open(file_path, 'r', encoding='utf-8') as file:&#13;
        return file.read()&#13;
&#13;
&#13;
# å°†æ•°æ®å†™å…¥æ–‡ä»¶ï¼Œä½¿ç”¨ utf-8 ç¼–ç &#13;
def write_to_file(data, file_path):&#13;
    with open(file_path, 'w', encoding='utf-8') as file:&#13;
        file.write(data)&#13;
&#13;
&#13;
# ç¤ºä¾‹ä½¿ç”¨&#13;
if __name__ == '__main__':&#13;
    # è¯»å–è¾“å…¥æ–‡ä»¶&#13;
    input_text = read_text_from_file('source.txt')&#13;
&#13;
    # å‹ç¼©æ•°æ®&#13;
    compressed, codes_table, root = huffman_compress(input_text)&#13;
&#13;
    # å†™å…¥å‹ç¼©åçš„æ•°æ®å’Œç¼–ç è¡¨åˆ°æ–‡ä»¶&#13;
    write_to_file(compressed, 'compressed.txt')&#13;
    write_to_file(str(codes_table), 'codes_table.txt')&#13;
&#13;
    # ä»æ–‡ä»¶ä¸­è¯»å–å‹ç¼©æ•°æ®è¿›è¡Œè§£å‹ç¼©ï¼ˆè¿™é‡Œä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨å˜é‡ï¼‰&#13;
    compressed_data = read_text_from_file('compressed.txt')&#13;
&#13;
    # è§£å‹æ•°æ®&#13;
    decompressed = huffman_decompress(compressed_data, root)&#13;
&#13;
    # å†™å…¥è§£å‹ç¼©åçš„æ•°æ®åˆ°æ–‡ä»¶&#13;
    write_to_file(decompressed, 'decompressed.txt')&#13;
&#13;
    print('Compression and decompression completed.')&#13;
&#13;
`ã€‚</description><guid isPermaLink="true">https://emo-ocean.github.io/post/Data%20Compression.html</guid><pubDate>Fri, 16 Aug 2024 08:15:06 +0000</pubDate></item><item><title>SMTPå®éªŒ</title><link>https://emo-ocean.github.io/post/SMTP-shi-yan.html</link><description># Computer Network SMTP Lab&#13;
### emailï¼šzehaiyu589@gmail.com ï¼ˆæºç æ–‡ç« æœ€åé™„æœ‰ï¼‰&#13;
### programming assignment : [SMTP.pdf](https://github.com/user-attachments/files/16276898/SMTP.pdf)&#13;
### programming assignment and others from ğŸ¥‡ https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/&#13;
&#13;
## ç¨‹åºå¤§è‡´æµç¨‹ ğŸ‘ &#13;
&#13;
&gt; å»ºç«‹TCPè¿æ¥ã€‚</description><guid isPermaLink="true">https://emo-ocean.github.io/post/SMTP-shi-yan.html</guid><pubDate>Thu, 18 Jul 2024 04:49:03 +0000</pubDate></item></channel></rss>