<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Emo-Ocean's Blog</title><link>https://emo-ocean.github.io</link><description>Exploring Concepts and Innovations</description><copyright>Emo-Ocean's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/116006682?v=4</url><title>avatar</title><link>https://emo-ocean.github.io</link></image><lastBuildDate>Fri, 16 Aug 2024 08:15:48 +0000</lastBuildDate><managingEditor>Emo-Ocean's Blog</managingEditor><ttl>60</ttl><webMaster>Emo-Ocean's Blog</webMaster><item><title>Data Compression</title><link>https://emo-ocean.github.io/post/Data%20Compression.html</link><description># 数据压缩&#13;
&#13;
## Huffman coding:&#13;
 在哈夫曼编码中，首先会统计文件中各字符出现的次数来代表权重，而权重大的字符出现次数更多，用以更短的编码序列（也就是更靠近根节点的层次）可以让压缩后的数据规模更小&#13;
&#13;
&#13;
```python&#13;
# 构建哈夫曼树&#13;
from collections import Counter&#13;
import heapq&#13;
&#13;
&#13;
class Node:&#13;
    def __init__(self, char, freq):&#13;
        self.char = char&#13;
        self.freq = freq&#13;
        self.left = None&#13;
        self.right = None&#13;
&#13;
    # 定义比较函数，使得Node类可以在优先队列中排序&#13;
    def __lt__(self, other):&#13;
        return self.freq &lt; other.freq&#13;
&#13;
&#13;
def build_huffman_tree(text_build):&#13;
    frequency = Counter(text_build)&#13;
    heap = [Node(char, freq) for char, freq in frequency.items()]&#13;
    heapq.heapify(heap)&#13;
&#13;
    while len(heap) &gt; 1:&#13;
        node1 = heapq.heappop(heap)&#13;
        node2 = heapq.heappop(heap)&#13;
        merged = Node(None, node1.freq + node2.freq)&#13;
        merged.left = node1&#13;
        merged.right = node2&#13;
        heapq.heappush(heap, merged)&#13;
&#13;
    return heap[0]&#13;
&#13;
&#13;
# 创建哈夫曼编码表&#13;
def build_codes_table(root_build):&#13;
    codes = {}&#13;
&#13;
    def build_codes(node, current_code):&#13;
        if node is None:&#13;
            return&#13;
&#13;
        if node.char is not None:&#13;
            codes[node.char] = current_code&#13;
&#13;
        build_codes(node.left, current_code + '0')&#13;
        build_codes(node.right, current_code + '1')&#13;
&#13;
    build_codes(root_build, '')&#13;
    return codes&#13;
&#13;
&#13;
# 压缩数据&#13;
def huffman_compress(text_compress):&#13;
    root_compress = build_huffman_tree(text_compress)&#13;
    codes_table_c = build_codes_table(root_compress)&#13;
    encoded_text = ''.join(codes_table_c[char] for char in text_compress)&#13;
    return encoded_text, codes_table_c, root_compress&#13;
&#13;
&#13;
# 解压数据&#13;
def huffman_decompress(encoded_text, root_decompress):&#13;
    decoded_text = []&#13;
    node = root_decompress&#13;
    for bit in encoded_text:&#13;
        if bit == '0':&#13;
            node = node.left&#13;
        else:&#13;
            node = node.right&#13;
&#13;
        if node.left is None and node.right is None:&#13;
            decoded_text.append(node.char)&#13;
            node = root_decompress&#13;
&#13;
    return ''.join(decoded_text)&#13;
&#13;
&#13;
# 从文件中读取文本数据，使用 utf-8 编码&#13;
def read_text_from_file(file_path):&#13;
    with open(file_path, 'r', encoding='utf-8') as file:&#13;
        return file.read()&#13;
&#13;
&#13;
# 将数据写入文件，使用 utf-8 编码&#13;
def write_to_file(data, file_path):&#13;
    with open(file_path, 'w', encoding='utf-8') as file:&#13;
        file.write(data)&#13;
&#13;
&#13;
# 示例使用&#13;
if __name__ == '__main__':&#13;
    # 读取输入文件&#13;
    input_text = read_text_from_file('source.txt')&#13;
&#13;
    # 压缩数据&#13;
    compressed, codes_table, root = huffman_compress(input_text)&#13;
&#13;
    # 写入压缩后的数据和编码表到文件&#13;
    write_to_file(compressed, 'compressed.txt')&#13;
    write_to_file(str(codes_table), 'codes_table.txt')&#13;
&#13;
    # 从文件中读取压缩数据进行解压缩（这里为了演示，我们直接使用变量）&#13;
    compressed_data = read_text_from_file('compressed.txt')&#13;
&#13;
    # 解压数据&#13;
    decompressed = huffman_decompress(compressed_data, root)&#13;
&#13;
    # 写入解压缩后的数据到文件&#13;
    write_to_file(decompressed, 'decompressed.txt')&#13;
&#13;
    print('Compression and decompression completed.')&#13;
&#13;
`。</description><guid isPermaLink="true">https://emo-ocean.github.io/post/Data%20Compression.html</guid><pubDate>Fri, 16 Aug 2024 08:15:06 +0000</pubDate></item><item><title>SMTP实验</title><link>https://emo-ocean.github.io/post/SMTP-shi-yan.html</link><description># Computer Network SMTP Lab&#13;
### email：zehaiyu589@gmail.com （源码文章最后附有）&#13;
### programming assignment : [SMTP.pdf](https://github.com/user-attachments/files/16276898/SMTP.pdf)&#13;
### programming assignment and others from 🥇 https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/&#13;
&#13;
## 程序大致流程 👍 &#13;
&#13;
&gt; 建立TCP连接。</description><guid isPermaLink="true">https://emo-ocean.github.io/post/SMTP-shi-yan.html</guid><pubDate>Thu, 18 Jul 2024 04:49:03 +0000</pubDate></item></channel></rss>